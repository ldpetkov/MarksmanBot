{"version":3,"sources":["webpack:///webpack/bootstrap 38d431000b6d91c3dd80","webpack:///./src/constants.js","webpack:///./src/actions.js","webpack:///./src/engine.js","webpack:///./src/presets.js","webpack:///./src/index.js","webpack:///./src/game.js","webpack:///./src/paytables/luchyLuchy.js","webpack:///external \"52-deck\""],"names":[],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 38d431000b6d91c3dd80","// @flow\n/*!\n * engine-blackjack\n * Copyright(c) 2016 Marco Casula\n * GPL 2.0 Licensed\n */\n\nexport const INVALID: string = 'INVALID'\nexport const RESTORE: string = 'RESTORE'\nexport const DEAL: string = 'DEAL'\nexport const INSURANCE: string = 'INSURANCE'\nexport const SPLIT: string = 'SPLIT'\nexport const HIT: string = 'HIT'\nexport const DOUBLE: string = 'DOUBLE'\nexport const STAND: string = 'STAND'\nexport const SURRENDER: string = 'SURRENDER'\nexport const SHOWDOWN: string = 'SHOWDOWN'\nexport const DEALER_HIT: string = 'DEALER-HIT'\nexport const RIGHT: string = 'right'\nexport const LEFT: string = 'left'\nexport const STAGE_READY: string = 'ready'\nexport const STAGE_PLAYER_TURN_RIGHT: string = 'player-turn-right'\nexport const STAGE_PLAYER_TURN_LEFT: string = 'player-turn-left'\nexport const STAGE_SHOWDOWN: string = 'showdown'\nexport const STAGE_DEALER_TURN: string = 'dealer-turn'\nexport const STAGE_DONE: string = 'done'\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","// @flow\n/*!\n engine-blackjack\n Copyright (C) 2016 Marco Casula\n\n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2 of the License.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License along\n with this program; if not, write to the Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\nimport * as TYPES from './constants'\nimport type { Action, Card } from './types'\n\nexport const invalid = (action: Action, info: any): Action => {\n  return {\n    type: TYPES.INVALID,\n    payload: {\n      type: action.type,\n      payload: action.payload,\n      info: info\n    }\n  }\n}\n\nexport const restore = (): Action => {\n  return {\n    type: TYPES.RESTORE\n  }\n}\n\nexport const deal = ({ bet = 10, sideBets = { luckyLucky: 0 } }: { bet: number, sideBets: any } = {}): Action => {\n  return {\n    type: TYPES.DEAL,\n    payload: {\n      bet,\n      sideBets\n    }\n  }\n}\n\nexport const insurance = ({ bet = 0 }: { bet: number }): Action => {\n  return {\n    type: TYPES.INSURANCE,\n    payload: {\n      bet\n    }\n  }\n}\n\nexport const split = (): Action => {\n  return {\n    type: TYPES.SPLIT\n  }\n}\n\nexport const hit = ({ position = 'right' }: { position: string }): Action => {\n  return {\n    type: TYPES.HIT,\n    payload: {\n      position\n    }\n  }\n}\n\nexport const double = ({ position = 'right' }: { position: string }): Action => {\n  return {\n    type: TYPES.DOUBLE,\n    payload: {\n      position\n    }\n  }\n}\n\nexport const stand = ({ position = 'right' }: { position: string }): Action => {\n  return {\n    type: TYPES.STAND,\n    payload: {\n      position\n    }\n  }\n}\n\nexport const surrender = (): Action => {\n  return {\n    type: TYPES.SURRENDER\n  }\n}\n\nexport const showdown = ({ dealerHoleCardOnly = false }: { dealerHoleCardOnly: boolean } = { }): Action => {\n  return {\n    type: TYPES.SHOWDOWN,\n    payload: {\n      dealerHoleCardOnly\n    }\n  }\n}\n\nexport const dealerHit = ({ dealerHoleCard }: { dealerHoleCard: Card } = { }): Action => {\n  return {\n    type: TYPES.DEALER_HIT,\n    payload: {\n      dealerHoleCard\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions.js","// @flow\n/*!\n engine-blackjack\n Copyright (C) 2016 Marco Casula\n\n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2 of the License.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License along\n with this program; if not, write to the Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\nimport luckyLucky from './paytables/luchyLuchy'\nimport * as TYPES from './constants'\nimport type { SideBets, Card, Hand, HandInfo, HandValue } from './types'\n\nexport const isNull = (obj: ?any): boolean => obj === null\n\nexport const isUndefined = (obj: ?any): boolean => obj === undefined\n\nexport const isNullOrUndef = (obj: ?any): boolean => isUndefined(obj) || isNull(obj)\n\nexport const calculate = (array: Array<Card>): HandValue => {\n  if (array.length === 1) {\n    if (isNullOrUndef(array[0])) {\n      return null\n    }\n    const value = array[0].value\n    return {\n      hi: value === 1 ? 11 : value,\n      lo: value === 1 ? 1 : value\n    }\n  }\n  const aces = []\n  const value = array.reduce((memo, x) => {\n    if (x.value === 1) {\n      aces.push(1)\n      return memo\n    }\n    memo += x.value\n    return memo\n  }, 0)\n  return aces.reduce((memo) => {\n    if ((memo.hi + 11) <= 21) {\n      memo.hi += 11\n      memo.lo += 1\n    } else {\n      memo.hi += 1\n      memo.lo += 1\n    }\n    if (memo.hi > 21 && memo.lo <= 21) {\n      memo.hi = memo.lo\n    }\n    return memo\n  }, {\n    hi: value,\n    lo: value\n  })\n}\n\nexport const getHigherValidValue = (handValue: HandValue):number => handValue.hi <= 21 ? handValue.hi : handValue.lo\n\nexport const checkForBusted = (handValue: HandValue): boolean => (handValue.hi > 21) && (handValue.lo === handValue.hi)\n\nexport const isBlackjack = (array: Array<Card>): boolean => array.length === 2 && calculate(array).hi === 21\n\nexport const isSoftHand = (array: Array<Card>): boolean => {\n  return array.some(x => x.value === 1) &&\n    array\n      .reduce((memo, x) => {\n        memo += (x.value === 1 && memo < 11) ? 11 : x.value\n        return memo\n      }, 0) === 17\n}\n\nexport const isSuited = (array: Array<Card> = []): boolean => {\n  if (array.length === 0) {\n    return false\n  }\n  const suite = array[0].suite\n  return array.every(x => x.suite === suite)\n}\n\nexport const countCards = (array: Array<Card>) => {\n  const systems = {\n    'Hi-Lo': [ -1, 1, 1, 1, 1, 1, 0, 0, 0, -1, -1, -1, -1 ]\n  }\n  return array.reduce((memo, x) => {\n    memo += systems['Hi-Lo'][x.value - 1]\n    return memo\n  }, 0)\n}\n\nexport const getHandInfo = (playerCards: Array<Card>, dealerCards: Array<Card>, hasSplit:boolean = false): Hand => {\n  const handValue = calculate(playerCards)\n  if (!handValue) {\n    return null\n  }\n  const hasBlackjack = isBlackjack(playerCards) && hasSplit === false\n  const hasBusted = checkForBusted(handValue)\n  const isClosed = hasBusted || hasBlackjack || handValue.hi === 21\n  const canDoubleDown = !isClosed && true\n  const canSplit = playerCards.length > 1 && playerCards[ 0 ].value === playerCards[ 1 ].value && !isClosed\n  const canInsure = dealerCards[ 0 ].value === 1 && !isClosed\n  return {\n    cards: playerCards,\n    playerValue: handValue,\n    playerHasBlackjack: hasBlackjack,\n    playerHasBusted: hasBusted,\n    playerHasSurrendered: false,\n    close: isClosed,\n    availableActions: {\n      double: canDoubleDown,\n      split: canSplit,\n      insurance: canInsure,\n      hit: !isClosed,\n      stand: !isClosed,\n      surrender: !isClosed\n    }\n  }\n}\n\nexport const getHandInfoAfterDeal = (playerCards: Array<Card>, dealerCards: Array<Card>, initialBet: number): Hand => {\n  const hand = getHandInfo(playerCards, dealerCards)\n  hand.bet = initialBet\n  // After deal, even if we got a blackjack the hand cannot be considered closed.\n  const availableActions = hand.availableActions\n  hand.availableActions = {\n    ...availableActions,\n    stand: true,\n    hit: true,\n    surrender: true\n  }\n  return {\n    ...hand,\n    close: hand.playerHasBlackjack\n  }\n}\n\nexport const getHandInfoAfterSplit = (playerCards: Array<Card>, dealerCards: Array<Card>, initialBet: number): Hand => {\n  const hand = getHandInfo(playerCards, dealerCards, true)\n  const availableActions = hand.availableActions\n  hand.availableActions = {\n    ...availableActions,\n    split: false,\n    double: !hand.close && (playerCards.length === 2),\n    insurance: false,\n    surrender: false\n  }\n  hand.bet = initialBet\n  return hand\n}\n\nexport const getHandInfoAfterHit = (playerCards: Array<Card>, dealerCards: Array<Card>, initialBet: number, hasSplit: boolean): Hand => {\n  const hand = getHandInfo(playerCards, dealerCards, hasSplit)\n  const availableActions = hand.availableActions\n  hand.availableActions = {\n    ...availableActions,\n    double: (playerCards.length === 2),\n    split: false,\n    insurance: false,\n    surrender: false\n  }\n  hand.bet = initialBet\n  return hand\n}\n\nexport const getHandInfoAfterDouble = (playerCards: Array<Card>, dealerCards: Array<Card>, initialBet: number, hasSplit: boolean): Hand => {\n  const hand = getHandInfoAfterHit(playerCards, dealerCards, initialBet, hasSplit)\n  const availableActions = hand.availableActions\n  hand.availableActions = {\n    ...availableActions,\n    hit: false,\n    stand: false\n  }\n  hand.bet = initialBet * 2\n  return {\n    ...hand,\n    close: true\n  }\n}\n\nexport const getHandInfoAfterStand = (handInfo: Hand): Hand => {\n  return {\n    ...handInfo,\n    close: true,\n    availableActions: {\n      double: false,\n      split: false,\n      insurance: false,\n      hit: false,\n      stand: false,\n      surrender: false\n    }\n  }\n}\n\nexport const getHandInfoAfterSurrender = (handInfo: Hand): Hand => {\n  const hand = getHandInfoAfterStand(handInfo)\n  return {\n    ...hand,\n    playerHasSurrendered: true,\n    close: true\n  }\n}\n\nexport const getHandInfoAfterInsurance = (playerCards: Array<Card>, dealerCards: Array<Card>): Hand => {\n  const hand = getHandInfo(playerCards, dealerCards)\n  const availableActions = hand.availableActions\n  hand.availableActions = {\n    ...availableActions,\n    stand: true,\n    hit: true,\n    surrender: true,\n    insurance: false\n  }\n  return {\n    ...hand,\n    close: hand.playerHasBlackjack\n  }\n}\n\nexport const isLuckyLucky = (playerCards: Array<Card>, dealerCards: Array<Card>): boolean => {\n  // Player hand and dealer's up card sum to 19, 20, or 21 (\"Lucky Lucky\")\n  const v1 = calculate(playerCards).hi + calculate(dealerCards).hi\n  const v2 = calculate(playerCards).lo + calculate(dealerCards).lo\n  const v3 = calculate(playerCards).hi + calculate(dealerCards).lo\n  const v4 = calculate(playerCards).lo + calculate(dealerCards).hi\n  return (v1 >= 19 && v1 <= 21) || (v2 >= 19 && v2 <= 21) || (v3 >= 19 && v3 <= 21) || (v4 >= 19 && v4 <= 21)\n}\n\nexport const getLuckyLuckyMultiplier = (playerCards: Array<Card>, dealerCards: Array<Card>) => {\n  const cards = [].concat(playerCards, dealerCards)\n  const isSameSuite = isSuited(cards)\n  const flatCards = cards.map(x => x.value).join('')\n  const value = calculate(cards)\n  return luckyLucky(flatCards, isSameSuite, value)\n}\n\nexport const isPerfectPairs = (playerCards: Array<Card>): boolean => playerCards[0].value === playerCards[1].value\n\nexport const getSideBetsInfo = (availableBets: SideBets, sideBets: SideBets, playerCards: Array<Card>, dealerCards: Array<Card>): any => {\n  const sideBetsInfo = {\n    luckyLucky: 0,\n    perfectPairs: 0\n  }\n  if (availableBets.luckyLucky && sideBets.luckyLucky && isLuckyLucky(playerCards, dealerCards)) {\n    const multiplier = getLuckyLuckyMultiplier(playerCards, dealerCards)\n    sideBetsInfo.luckyLucky = sideBets.luckyLucky * multiplier\n  }\n  if (availableBets.perfectPairs && sideBets.perfectPairs && isPerfectPairs(playerCards)) {\n    // TODO: impl colored pairs\n    // TODO: impl mixed pairs\n    sideBetsInfo.perfectPairs = sideBets.perfectPairs * 5\n  }\n  return sideBetsInfo\n}\n\nexport const isActionAllowed = (actionName: string, stage: string): boolean => {\n  if (actionName === TYPES.RESTORE) {\n    return true\n  }\n  switch (stage) {\n    case TYPES.STAGE_READY: {\n      return [TYPES.RESTORE, TYPES.DEAL].indexOf(actionName) > -1\n    }\n    case TYPES.STAGE_PLAYER_TURN_RIGHT: {\n      return [TYPES.STAND, TYPES.INSURANCE, TYPES.SURRENDER, TYPES.SPLIT, TYPES.HIT, TYPES.DOUBLE].indexOf(actionName) > -1\n    }\n    case TYPES.STAGE_PLAYER_TURN_LEFT: {\n      return [TYPES.STAND, TYPES.HIT, TYPES.DOUBLE].indexOf(actionName) > -1\n    }\n    case TYPES.SHOWDOWN: {\n      return [TYPES.SHOWDOWN, TYPES.STAND].indexOf(actionName) > -1\n    }\n    case TYPES.STAGE_DEALER_TURN: {\n      return [TYPES.DEALER_HIT].indexOf(actionName) > -1\n    }\n    default: {\n      return false\n    }\n  }\n}\n\nexport const getPrize = (playerHand: Hand, dealerCards: Array<Card>): number => {\n  const {\n    close = false,\n    playerHasSurrendered = true,\n    playerHasBlackjack = false,\n    playerHasBusted = true,\n    playerValue = {},\n    bet = 0\n  } = playerHand\n  const higherValidDealerValue = getHigherValidValue(calculate(dealerCards))\n  const dealerHasBlackjack = isBlackjack(dealerCards)\n  if (!close) {\n    return 0\n  }\n  if (playerHasBusted) {\n    return 0\n  }\n  if (playerHasSurrendered) {\n    return bet / 2\n  }\n  if (playerHasBlackjack && !dealerHasBlackjack) {\n    return bet + (bet * 1.5)\n  }\n  const dealerHasBusted = higherValidDealerValue > 21\n  if (dealerHasBusted) {\n    return (bet + bet)\n  }\n  const higherValidPlayerValue = getHigherValidValue(playerValue)\n  if (higherValidPlayerValue > higherValidDealerValue) {\n    return (bet + bet)\n  } else if (higherValidPlayerValue === higherValidDealerValue) {\n    return bet\n  }\n  return 0\n}\n\nexport const getPrizes = ({ history, handInfo: { left, right }, dealerCards }: { history: Array<any>, handInfo: HandInfo, dealerCards: Array<Card>}) => {\n  const finalBet = history.reduce((memo, x) => {\n    memo += x.value\n    return memo\n  }, 0)\n  const wonOnRight = getPrize(right, dealerCards)\n  const wonOnLeft = getPrize(left, dealerCards)\n  return {\n    finalBet: finalBet,\n    wonOnRight: wonOnRight,\n    wonOnLeft: wonOnLeft\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/engine.js","// @flow\n/*!\n engine-blackjack\n Copyright (C) 2016 Marco Casula\n\n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2 of the License.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License along\n with this program; if not, write to the Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\nimport * as TYPES from './constants'\nimport { shuffle, newDecks } from '52-deck'\nimport type { SideBets, Rule, State } from './types'\n\nexport const getDefaultSideBets = (active: boolean = false) : SideBets => {\n  return {\n    luckyLucky: active,\n    perfectPairs: active,\n    royalMatch: active,\n    luckyLadies: active,\n    inBet: active,\n    MatchTheDealer: active\n  }\n}\n\nexport const getRules = ({\n  decks = 1,\n  standOnSoft17 = true,\n  double = 'any',\n  split = true,\n  doubleAfterSplit = true,\n  surrender = true,\n  insurance = true,\n  showdownAfterAceSplit = true\n}: Rule) => {\n  return {\n    decks: decks || 1,\n    standOnSoft17: standOnSoft17,\n    double: double,\n    split: split,\n    doubleAfterSplit: doubleAfterSplit,\n    surrender: surrender,\n    insurance: insurance,\n    showdownAfterAceSplit: showdownAfterAceSplit\n  }\n}\n\nexport const defaultState = (rules: Rule) : State => {\n  return {\n    hits: 0,\n    initialBet: 0,\n    finalBet: 0,\n    finalWin: 0,\n    wonOnRight: 0,\n    wonOnLeft: 0,\n    stage: TYPES.STAGE_READY,\n    deck: shuffle(newDecks(rules.decks)),\n    handInfo: {\n      left: {},\n      right: {}\n    },\n    history: [],\n    availableBets: getDefaultSideBets(true),\n    sideBetsInfo: {},\n    rules: rules,\n    dealerHoleCard: null,\n    dealerHasBlackjack: false,\n    dealerHasBusted: false\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/presets.js","// @flow\n/*!\n * engine-blackjack\n * Copyright(c) 2016 Marco Casula\n * GPL 2.0 Licensed\n */\n\n'use strict'\nimport * as constants from './constants'\nimport * as engine from './engine'\nimport * as presets from './presets'\nimport * as actions from './actions'\nimport Game from './game'\n\nexport {\n  constants,\n  engine,\n  presets,\n  actions,\n  Game\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// @flow\n/*!\n engine-blackjack\n Copyright (C) 2016 Marco Casula\n\n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2 of the License.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License along\n with this program; if not, write to the Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\nimport * as TYPES from './constants'\nimport * as engine from './engine'\nimport type { Action, State, Hand, HandValue, Rule } from './types'\nimport { defaultState, getDefaultSideBets, getRules } from './presets'\nconst actions = require('./actions')\n\nconst appendEpoch = (obj) => {\n  const { payload = { bet: 0 } } = obj\n  return Object.assign(\n    {},\n    obj,\n    {\n      value: payload.bet || 0,\n      ts: new Date().getTime()\n    }\n  )\n}\n\nexport default class Game {\n  state: State = {}\n  dispatch: Function\n  _dispatch: Function\n  getState: Function\n  setState: Function\n  enforceRules: Function\n  constructor (initialState: State, rules: Rule = getRules({})) {\n    this.state = initialState ? Object.assign({}, initialState) : defaultState(rules)\n    this.dispatch = this.dispatch.bind(this)\n    this.getState = this.getState.bind(this)\n    this.setState = this.setState.bind(this)\n    this.enforceRules = this.enforceRules.bind(this)\n    this._dispatch = this._dispatch.bind(this)\n  }\n\n  canDouble (double: string, playerValue: HandValue): boolean {\n    if (double === 'none') {\n      return false\n    } else if (double === '9or10') {\n      return ((playerValue.hi === 9) || (playerValue.hi === 10))\n    } else if (double === '9or10or11') {\n      return ((playerValue.hi >= 9) && (playerValue.hi <= 11))\n    } else if (double === '9thru15') {\n      return ((playerValue.hi >= 9) && (playerValue.hi <= 15))\n    } else {\n      return true\n    }\n  }\n\n  enforceRules (handInfo: Hand): Hand {\n    const { availableActions } = handInfo\n    const { playerValue } = handInfo\n    const { rules, history } = this.state\n    if (!this.canDouble(rules.double, playerValue)) {\n      availableActions.double = false\n    }\n    if (!rules.split) {\n      availableActions.split = false\n    }\n    if (!rules.surrender) {\n      availableActions.surrender = false\n    }\n    if (!rules.doubleAfterSplit) {\n      if (history.some(x => x.type === TYPES.SPLIT)) {\n        availableActions.double = false\n      }\n    }\n    if (!rules.insurance) {\n      availableActions.insurance = false\n    }\n    return handInfo\n  }\n\n  getState () : State {\n    return {\n      ...this.state\n    }\n  }\n\n  setState (state: State): void {\n    this.state = {\n      ...this.state,\n      ...state\n    }\n  }\n\n  dispatch (action: Action): State {\n    const { stage, handInfo, history } = this.state\n    const { type, payload = {} } = action\n    const { position = TYPES.RIGHT } = payload\n    const isLeft = position === TYPES.LEFT\n    const historyHasSplit = history.some(x => x.type === TYPES.SPLIT)\n    const hand = handInfo[position]\n\n    let isActionAllowed = engine.isActionAllowed(type, stage)\n\n    if (!isActionAllowed) {\n      return this._dispatch(actions.invalid(action, `${type} is not allowed when stage is ${stage}`))\n    }\n\n    const whiteList = [TYPES.RESTORE, TYPES.DEAL, TYPES.SHOWDOWN]\n\n    if (isActionAllowed && whiteList.some(x => x === type)) {\n      // this is a safe action. We do not need to check the status of the stage\n      // so we return the result now!\n      if (type === TYPES.DEAL && typeof payload.bet !== 'number') {\n        return this._dispatch(actions.invalid(action, `${type} without bet value on stage ${stage}`))\n      }\n      return this._dispatch(action)\n    }\n\n    if (hand.close) {\n      // TODO: consolidate this one, probably is just enough to consider the availableActions (see more below)\n      return this._dispatch(actions.invalid(action, `${type} is not allowed because \"${position}\" side of the table is closed on \"${stage}\"`))\n    }\n\n    if (isLeft && !historyHasSplit) {\n      // You want to do something on \"left\" but no split found in history.\n      // default side is \"right\". When an action want to edit the \"left\" side of the table\n      // a valid split should be appear in the history. If not, \"left\" position is not ready to be changed\n      if (!history.some(x => x.type === TYPES.SPLIT)) {\n        return this._dispatch(actions.invalid(action, `${type} is not allowed because there is no SPLIT in current stage \"${stage}\"`))\n      }\n    }\n\n    if (isLeft && !handInfo.right.close) {\n      // You want to do something on \"left\" but \"right\" is still open\n      return this._dispatch(actions.invalid(action, `${type} is not allowed because you need to finish \"left\" hand \"${stage}\"`))\n    }\n\n    if (!hand.availableActions[type.toLowerCase()]) {\n      return this._dispatch(actions.invalid(action, `${type} is not currently allowed on position \"${position}\". Stage is \"${stage}\"`))\n    }\n\n    return this._dispatch(action)\n  }\n\n  _dispatch (action: Action): State {\n    switch (action.type) {\n      case TYPES.DEAL: {\n        const { bet, sideBets } = action.payload\n        const { rules: { insurance }, availableBets, history, hits } = this.state\n        const playerCards = this.state.deck.splice(this.state.deck.length - 2, 2)\n        const dealerCards = this.state.deck.splice(this.state.deck.length - 1, 1)\n        const dealerHoleCard = this.state.deck.splice(this.state.deck.length - 1, 1)[ 0 ]\n        const dealerValue = engine.calculate(dealerCards)\n        let dealerHasBlackjack = engine.isBlackjack(dealerCards.concat([dealerHoleCard]))\n        const right = this.enforceRules(engine.getHandInfoAfterDeal(playerCards, dealerCards, bet))\n        if (insurance && dealerValue.lo === 1) {\n          dealerHasBlackjack = false\n          right.availableActions = {\n            ...right.availableActions,\n            stand: false,\n            double: false,\n            hit: false,\n            split: false,\n            surrender: false\n          }\n        }\n        const sideBetsInfo = engine.getSideBetsInfo(availableBets, sideBets, playerCards, dealerCards)\n        const historyItem = appendEpoch({\n          ...action,\n          right: playerCards,\n          dealerCards\n        })\n        this.setState({\n          initialBet: bet,\n          stage: TYPES.STAGE_PLAYER_TURN_RIGHT,\n          dealerCards: dealerCards,\n          dealerHoleCard: dealerHoleCard,\n          dealerValue: dealerValue,\n          dealerHasBlackjack: dealerHasBlackjack,\n          deck: this.state.deck.filter(x => dealerCards\n              .concat(playerCards)\n              .indexOf(x) === -1),\n          cardCount: engine.countCards(playerCards.concat(dealerCards)),\n          handInfo: {\n            left: {},\n            right\n          },\n          sideBetsInfo: sideBetsInfo,\n          availableBets: getDefaultSideBets(false),\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n\n        if (right.playerHasBlackjack) {\n          // purpose of the game archived !!!\n          this._dispatch(actions.showdown())\n          break\n        }\n        if (dealerHasBlackjack) {\n          if (!right.availableActions.insurance) {\n            // nothing left, let's go and tell the customer he loses this game\n            this._dispatch(actions.showdown())\n          }\n        // else\n        // in this case, the game must continue in \"player-turn-right\"\n        // waiting for the insurance action\n        }\n        break\n      }\n      case TYPES.INSURANCE: {\n        const { bet = 0 } = action.payload\n        const { sideBetsInfo, handInfo, dealerCards, dealerHoleCard, initialBet, history, hits } = this.state\n        const dealerHasBlackjack = engine.isBlackjack(dealerCards.concat([dealerHoleCard]))\n        const insuranceValue = bet > 0 ? initialBet / 2 : 0\n        const isFirstCardAce = dealerCards[0].value === 1\n        const insurancePrize = (isFirstCardAce && dealerHasBlackjack && insuranceValue > 0 && bet > 0) ? insuranceValue * 3 : 0\n        const right = this.enforceRules(engine.getHandInfoAfterInsurance(handInfo.right.cards, dealerCards))\n        right.bet = initialBet\n        right.close = dealerHasBlackjack\n        const historyItem = appendEpoch({\n          ...action,\n          payload: { bet: insuranceValue || 0 }\n        })\n        this.setState({\n          handInfo: { left: {}, right },\n          history: history.concat(historyItem),\n          hits: hits + 1,\n          sideBetsInfo: {\n            ...sideBetsInfo,\n            insurance: {\n              risk: insuranceValue,\n              win: insurancePrize\n            }\n          }\n        })\n        if (dealerHasBlackjack) {\n          this._dispatch(actions.showdown())\n        }\n        break\n      }\n      case TYPES.SPLIT: {\n        const { rules, initialBet, handInfo, dealerCards, history, hits } = this.state\n        let deck = this.state.deck\n        const playerCardsLeftPosition = [handInfo.right.cards[ 0 ]]\n        const playerCardsRightPosition = [handInfo.right.cards[ 1 ]]\n        const forceShowdown = rules.showdownAfterAceSplit && playerCardsRightPosition[ 0 ].value === 1\n        let cardRight = deck.splice(deck.length - 2, 1)\n        let cardLeft = deck.splice(deck.length - 1, 1)\n        deck = deck.filter(x => [ cardLeft, cardRight ].indexOf(x) === -1)\n        playerCardsLeftPosition.push(cardLeft[ 0 ])\n        playerCardsRightPosition.push(cardRight[ 0 ])\n        const historyItem = appendEpoch({\n          ...action,\n          payload: { bet: initialBet },\n          left: playerCardsLeftPosition,\n          right: playerCardsRightPosition\n        })\n        let left = this.enforceRules(engine.getHandInfoAfterSplit(playerCardsLeftPosition, dealerCards, initialBet))\n        let right = this.enforceRules(engine.getHandInfoAfterSplit(playerCardsRightPosition, dealerCards, initialBet))\n        let stage = ''\n        if (forceShowdown) {\n          stage = TYPES.STAGE_SHOWDOWN\n          left.close = true\n          right.close = true\n        } else {\n          if (right.close) {\n            stage = TYPES.STAGE_PLAYER_TURN_LEFT\n          } else {\n            stage = TYPES.STAGE_PLAYER_TURN_RIGHT\n          }\n        }\n        if (right.close && left.close) {\n          stage = TYPES.STAGE_SHOWDOWN\n        }\n        this.setState({\n          stage: stage,\n          handInfo: {\n            left,\n            right\n          },\n          deck: deck,\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        if (stage === TYPES.STAGE_SHOWDOWN) {\n          this._dispatch(actions.showdown())\n        }\n        break\n      }\n      case TYPES.HIT: {\n        let stage = ''\n        const { initialBet, deck, handInfo, dealerCards, cardCount, history, hits } = this.state\n        const position = action.payload.position\n        const card = deck.splice(deck.length - 1, 1)\n        let playerCards = []\n        let left = {}\n        let right = {}\n        const hasSplit = history.some(x => x.type === TYPES.SPLIT)\n        if (position === TYPES.LEFT) {\n          playerCards = handInfo.left.cards.concat(card)\n          left = engine.getHandInfoAfterHit(playerCards, dealerCards, initialBet, hasSplit)\n          right = Object.assign({}, handInfo.right)\n          if (left.close) {\n            stage = TYPES.STAGE_SHOWDOWN\n          } else {\n            stage = `player-turn-${position}`\n          }\n        } else {\n          playerCards = handInfo.right.cards.concat(card)\n          right = engine.getHandInfoAfterHit(playerCards, dealerCards, initialBet, hasSplit)\n          left = Object.assign({}, handInfo.left)\n          if (right.close) {\n            if (history.some(x => x.type === TYPES.SPLIT)) {\n              stage = TYPES.STAGE_PLAYER_TURN_LEFT\n            } else {\n              stage = TYPES.STAGE_SHOWDOWN\n            }\n          } else {\n            stage = `player-turn-${position}`\n          }\n          if (right.close && left.close) {\n            stage = TYPES.STAGE_SHOWDOWN\n          }\n        }\n        const objCards = {}\n        objCards[position] = playerCards\n        const historyItem = appendEpoch({\n          ...action,\n          ...objCards\n        })\n        this.setState({\n          stage: stage,\n          handInfo: { left, right },\n          deck: deck.filter(x => playerCards.indexOf(x) === -1),\n          cardCount: cardCount + engine.countCards(card),\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        if (stage === TYPES.STAGE_SHOWDOWN) {\n          this._dispatch(actions.showdown())\n        }\n        break\n      }\n      case TYPES.DOUBLE: {\n        let stage = ''\n        const { initialBet, deck, handInfo, dealerCards, cardCount, history, hits } = this.state\n        const position = action.payload.position\n        const card = deck.splice(deck.length - 1, 1)\n        let playerCards: Array<card> = []\n        let left = {}\n        let right = {}\n        const hasSplit = history.some(x => x.type === TYPES.SPLIT)\n        // TODO: remove position and replace it with stage info #hit\n        if (position === TYPES.LEFT) {\n          right = Object.assign({}, handInfo.right)\n          playerCards = handInfo.left.cards.concat(card)\n          left = engine.getHandInfoAfterDouble(playerCards, dealerCards, initialBet, hasSplit)\n          if (left.close) {\n            stage = TYPES.STAGE_SHOWDOWN\n          } else {\n            stage = `player-turn-${position}`\n          }\n        } else {\n          playerCards = handInfo.right.cards.concat(card)\n          left = Object.assign({}, handInfo.left)\n          right = engine.getHandInfoAfterDouble(playerCards, dealerCards, initialBet, hasSplit)\n          if (right.close) {\n            if (history.some(x => x.type === TYPES.SPLIT)) {\n              stage = TYPES.STAGE_PLAYER_TURN_LEFT\n            } else {\n              stage = TYPES.STAGE_SHOWDOWN\n            }\n          } else {\n            stage = `player-turn-${position}`\n          }\n        }\n        const objCards = {}\n        objCards[position] = playerCards\n        const historyItem = appendEpoch({\n          ...action,\n          payload: { bet: initialBet },\n          ...objCards\n        })\n        this.setState({\n          stage: stage,\n          handInfo: { left, right },\n          deck: deck.filter(x => playerCards.indexOf(x) === -1),\n          cardCount: cardCount + engine.countCards(card),\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        this._dispatch(actions.stand(position))\n        break\n      }\n      case TYPES.STAND: {\n        let stage = ''\n        const { handInfo, history, hits } = this.state\n        const position = action.payload.position\n        let left = {}\n        let right = {}\n        const hasSplit = history.some(x => x.type === TYPES.SPLIT)\n        if (position === TYPES.LEFT) {\n          right = Object.assign({}, handInfo.right)\n          left = engine.getHandInfoAfterStand(handInfo.left)\n          stage = TYPES.STAGE_SHOWDOWN\n        }\n        if (position === TYPES.RIGHT) {\n          left = Object.assign({}, handInfo.left)\n          right = engine.getHandInfoAfterStand(handInfo.right)\n          if (right.close) {\n            stage = TYPES.STAGE_SHOWDOWN\n          }\n        }\n        if (hasSplit) {\n          stage = stage !== TYPES.STAGE_SHOWDOWN ? TYPES.STAGE_PLAYER_TURN_LEFT : TYPES.STAGE_SHOWDOWN\n        }\n        if (hasSplit && !left.close) {\n          stage = TYPES.STAGE_PLAYER_TURN_LEFT\n        }\n        const historyItem = appendEpoch(action)\n        this.setState({\n          stage,\n          handInfo: { left, right },\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        if (stage === TYPES.STAGE_SHOWDOWN) {\n          this._dispatch(actions.showdown())\n        }\n        break\n      }\n      case TYPES.SHOWDOWN: {\n        const { dealerHoleCard, handInfo, history, hits } = this.state\n        const { dealerHoleCardOnly } = action.payload\n        const historyItem = appendEpoch(action)\n        this.setState({\n          stage: TYPES.STAGE_DEALER_TURN,\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        // we want to include in the calculation the dealerHoleCard obtained in initial deal()\n        this._dispatch(actions.dealerHit({ dealerHoleCard: dealerHoleCard }))\n        if (dealerHoleCardOnly) {\n          this.setState({\n            stage: TYPES.STAGE_DONE,\n            ...engine.getPrizes(this.state)\n          })\n          break\n        }\n        const checkLeftStatus = history.some(x => x.type === TYPES.SPLIT)\n        const check1 = (handInfo.right.playerHasBusted || handInfo.right.playerHasBlackjack) && !checkLeftStatus\n        if (check1) {\n          this.setState({\n            stage: TYPES.STAGE_DONE,\n            ...engine.getPrizes(this.state)\n          })\n          break\n        }\n        const check2 = checkLeftStatus && (handInfo.left.playerHasBusted || handInfo.left.playerHasBlackjack) && check1\n        if (check2) {\n          this.setState({\n            stage: TYPES.STAGE_DONE,\n            ...engine.getPrizes(this.state)\n          })\n          break\n        }\n        if (checkLeftStatus && handInfo.left.playerHasBusted && handInfo.right.playerHasBusted) {\n          this.setState({\n            stage: TYPES.STAGE_DONE,\n            ...engine.getPrizes(this.state)\n          })\n          break\n        }\n        while (this.getState().stage === TYPES.STAGE_DEALER_TURN) {\n          this._dispatch(actions.dealerHit())\n        }\n        this.setState({\n          ...engine.getPrizes(this.state)\n        })\n        break\n      }\n      case TYPES.SURRENDER: {\n        const { handInfo, history, hits } = this.state\n        handInfo.right = engine.getHandInfoAfterSurrender(handInfo.right)\n        const historyItem = appendEpoch(action)\n        this.setState({\n          stage: TYPES.STAGE_SHOWDOWN,\n          handInfo: handInfo,\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        this._dispatch(actions.showdown({ dealerHoleCardOnly: true }))\n        break\n      }\n      case TYPES.DEALER_HIT: {\n        const { rules, deck, cardCount, history, hits } = this.state\n        // the new card for dealer can be the \"dealerHoleCard\" or a new card\n        // dealerHoleCard was set at the deal()\n        const { dealerHoleCard } = action.payload\n        const card = dealerHoleCard || deck.splice(deck.length - 1, 1)[ 0 ]\n        const dealerCards = this.state.dealerCards.concat([card])\n        const dealerValue = engine.calculate(dealerCards)\n        const dealerHasBlackjack = engine.isBlackjack(dealerCards)\n        const dealerHasBusted = dealerValue.hi > 21\n        let stage = null\n        if (dealerValue.hi < 17) {\n          stage = TYPES.STAGE_DEALER_TURN\n        } else {\n          if (!rules.standOnSoft17 && engine.isSoftHand(dealerCards)) {\n            stage = TYPES.STAGE_DEALER_TURN\n          } else {\n            stage = TYPES.STAGE_DONE\n          }\n        }\n        const historyItem = appendEpoch({\n          ...action,\n          dealerCards\n        })\n        this.setState({\n          stage: stage,\n          dealerCards: dealerCards,\n          dealerValue: dealerValue,\n          dealerHasBlackjack: dealerHasBlackjack,\n          dealerHasBusted: dealerHasBusted,\n          deck: deck.filter(x => dealerCards.indexOf(x) === -1),\n          cardCount: cardCount + engine.countCards([card]),\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        break\n      }\n      default: {\n        const { history, hits } = this.state\n        const historyItem = appendEpoch(action)\n        this.setState({\n          hits: hits + 1,\n          history: history.concat(historyItem)\n        })\n        break\n      }\n    }\n    return this.getState()\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/game.js","export default (flatCards, suited, value) => {\n  const key = `${flatCards}${suited ? 's' : ''}`\n  if (key === '777s') {\n    return 200\n  }\n  if (key === '678s') {\n    return 100\n  }\n  if (key === '777') {\n    return 50\n  }\n  if (key === '678') {\n    return 30\n  }\n  if ((value.hi === 21 || value.lo === 21) && suited) {\n    return 10\n  }\n  if ((value.hi === 21 || value.lo === 21) && !suited) {\n    return 3\n  }\n  if ((value.hi === 20 || value.lo === 20)) {\n    return 3\n  }\n  if (value.hi === 19 || value.lo === 19) {\n    return 2\n  }\n  return 0\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/paytables/luchyLuchy.js","module.exports = require(\"52-deck\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"52-deck\"\n// module id = 7\n// module chunks = 0"],"sourceRoot":""}